<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Land</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        #gameContainer {
            max-width: 800px;
            margin: 0 auto;
        }

        #gameMap {
            background-color: #000;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px;
            margin: 20px 0;
            white-space: pre;
            line-height: 1;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            letter-spacing: 0;
            width: fit-content;
        }

        #gameInfo {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        .info-panel {
            background-color: #001100;
            border: 1px solid #00ff00;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>Endless Land</h1>

        <div id="gameInfo">
            <div class="info-panel">
                <strong>Player:</strong> @<br>
                <strong>Position:</strong> <span id="playerPos">5,5</span>
            </div>
            <div class="info-panel">
                <strong>Health:</strong> 100/100<br>
                <strong>Level:</strong> 1
            </div>
        </div>

        <div id="gameMap"></div>

        <div id="controls" class="info-panel">
            <strong>Controls:</strong> Use WASD to move, M for map mode, G to generate AI map
        </div>

        <div id="messages" class="info-panel">
            <strong>Message:</strong> Game started!
        </div>
    </div>

    <script>
        class SimpleRPG {
            constructor() {
                // Backend configuration
                this.API_BASE_URL = 'https://your-api-id.execute-api.us-east-1.amazonaws.com/dev';
                this.WS_URL = 'wss://your-websocket-id.execute-api.us-east-1.amazonaws.com/dev';
                this.websocket = null;
                this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.isConnected = false;
                // Game constants
                this.CONSTANTS = {
                    MAP_WIDTH: 80,
                    MAP_HEIGHT: 40,
                    VIEWPORT_WIDTH: 35,
                    VIEWPORT_HEIGHT: 20,
                    INITIAL_PLAYER_X: 10,
                    INITIAL_PLAYER_Y: 10,
                    EXIT_WIDTH: 3
                };

                // Map configurations
                this.MAP_CONFIGS = {
                    0: { theme: 'forest', exits: [{x: 39, y: 0, targetMap: 1, targetX: 39, targetY: 38}, {x: 79, y: 20, targetMap: 2, targetX: 1, targetY: 20}] },
                    1: { theme: 'plains', exits: [{x: 39, y: 39, targetMap: 0, targetX: 39, targetY: 1}, {x: 20, y: 0, targetMap: 3, targetX: 20, targetY: 38}] },
                    2: { theme: 'desert', exits: [{x: 0, y: 20, targetMap: 0, targetX: 78, targetY: 20}, {x: 39, y: 39, targetMap: 4, targetX: 39, targetY: 1}] },
                    3: { theme: 'mountains', exits: [{x: 20, y: 39, targetMap: 1, targetX: 20, targetY: 1}, {x: 79, y: 15, targetMap: 5, targetX: 1, targetY: 15}] },
                    4: { theme: 'village', exits: [{x: 39, y: 0, targetMap: 2, targetX: 39, targetY: 38}, {x: 0, y: 20, targetMap: 6, targetX: 78, targetY: 20}] },
                    5: { theme: 'cave', exits: [{x: 0, y: 15, targetMap: 3, targetX: 78, targetY: 15}] },
                    6: { theme: 'lake', exits: [{x: 79, y: 20, targetMap: 4, targetX: 1, targetY: 20}] }
                };

                // Theme object configurations
                this.THEME_CONFIGS = {
                    forest: { objects: [{ type: 'T', count: 30, probability: 1.0 }] },
                    plains: { objects: [{ type: 'T', count: 8, probability: 1.0 }] },
                    desert: { objects: [{ type: 'C', count: 15, probability: 0.7 }, { type: 'R', count: 15, probability: 0.3 }] },
                    mountains: { objects: [{ type: 'R', count: 20, probability: 0.8 }, { type: 'T', count: 20, probability: 0.2 }] },
                    village: { objects: [{ type: 'H', count: 12, probability: 1.0 }] },
                    cave: { objects: [{ type: 'S', count: 25, probability: 0.6 }, { type: 'R', count: 25, probability: 0.4 }] },
                    lake: { objects: [{ type: 'W', count: 18, probability: 0.5 }, { type: 'T', count: 18, probability: 0.5 }] }
                };

                // Game state
                this.mapWidth = this.CONSTANTS.MAP_WIDTH;
                this.mapHeight = this.CONSTANTS.MAP_HEIGHT;
                this.viewportWidth = this.CONSTANTS.VIEWPORT_WIDTH;
                this.viewportHeight = this.CONSTANTS.VIEWPORT_HEIGHT;
                this.playerX = this.CONSTANTS.INITIAL_PLAYER_X;
                this.playerY = this.CONSTANTS.INITIAL_PLAYER_Y;
                this.currentMapId = 0;
                
                // Map mode state
                this.isMapMode = false;
                this.mapModeCurrentMap = 0;
                this.mapModeViewX = 0;
                this.mapModeViewY = 0;
                this.visitedAreas = {};

                // Initialize maps
                this.maps = [];
                this.initializeMaps();

                // Register event listeners
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));

                // Connect to backend
                this.connectWebSocket();

                // Initial area recording and rendering
                this.recordVisitedArea();
                this.render();
            }

            // ===== MAP INITIALIZATION =====
            initializeMaps() {
                for (let mapId in this.MAP_CONFIGS) {
                    this.maps[mapId] = this.createMap(this.MAP_CONFIGS[mapId]);
                }
            }

            // ===== MAP GENERATION HELPERS =====
            createEmptyMap() {
                let map = [];
                for (let y = 0; y < this.mapHeight; y++) {
                    map[y] = [];
                    for (let x = 0; x < this.mapWidth; x++) {
                        map[y][x] = '.';
                    }
                }
                return map;
            }

            createBoundaryWalls(map) {
                // Horizontal walls
                for (let x = 0; x < this.mapWidth; x++) {
                    map[0][x] = '#';
                    map[this.mapHeight - 1][x] = '#';
                }
                // Vertical walls
                for (let y = 0; y < this.mapHeight; y++) {
                    map[y][0] = '#';
                    map[y][this.mapWidth - 1] = '#';
                }
            }

            createExits(map, exits) {
                if (!exits) return;

                exits.forEach(exit => {
                    map[exit.y][exit.x] = '.';
                    // Create exit width based on constant
                    const halfWidth = Math.floor(this.CONSTANTS.EXIT_WIDTH / 2);
                    for (let i = 1; i <= halfWidth; i++) {
                        if (exit.x - i >= 0) map[exit.y][exit.x - i] = '.';
                        if (exit.x + i < this.mapWidth) map[exit.y][exit.x + i] = '.';
                    }
                });
            }

            placeRandomObject(map, objectType, count, probability = 1.0) {
                for (let i = 0; i < count; i++) {
                    if (Math.random() > probability) continue;

                    let x = Math.floor(Math.random() * (this.mapWidth - 2)) + 1;
                    let y = Math.floor(Math.random() * (this.mapHeight - 2)) + 1;

                    if (map[y][x] === '.') {
                        map[y][x] = objectType;
                    }
                }
            }

            populateMapWithTheme(map, theme) {
                const themeConfig = this.THEME_CONFIGS[theme];
                if (!themeConfig) return;

                themeConfig.objects.forEach(objConfig => {
                    this.placeRandomObject(map, objConfig.type, objConfig.count, objConfig.probability);
                });
            }

            createMap(config) {
                const map = this.createEmptyMap();
                this.createBoundaryWalls(map);
                this.createExits(map, config.exits);
                this.populateMapWithTheme(map, config.theme);

                return { map, exits: config.exits || [] };
            }

            // ===== INPUT HANDLING =====
            handleKeyPress(event) {
                if (event.key === 'm' || event.key === 'M') {
                    this.toggleMapMode();
                    return;
                }

                if (event.key === 'g' || event.key === 'G') {
                    // Generate AI map - example: crystal cave
                    this.generateMapWithAI('crystal cave', 'A mysterious underground cavern filled with glowing crystals');
                    return;
                }

                if (this.isMapMode) {
                    this.handleMapModeInput(event);
                    return;
                }

                const movement = this.getMovementFromKey(event.key);
                if (!movement) return;

                const newX = this.playerX + movement.dx;
                const newY = this.playerY + movement.dy;

                if (this.canMoveTo(newX, newY)) {
                    this.movePlayer(movement.dx, movement.dy);
                } else {
                    this.updateMessage("Cannot move in that direction!");
                }
            }

            getMovementFromKey(key) {
                const movements = {
                    'w': { dx: 0, dy: -1 },
                    'W': { dx: 0, dy: -1 },
                    'a': { dx: -1, dy: 0 },
                    'A': { dx: -1, dy: 0 },
                    's': { dx: 0, dy: 1 },
                    'S': { dx: 0, dy: 1 },
                    'd': { dx: 1, dy: 0 },
                    'D': { dx: 1, dy: 0 }
                };
                return movements[key];
            }

            // ===== PLAYER MOVEMENT =====

            canMoveTo(x, y) {
                if (!this.isWithinMapBounds(x, y)) return false;
                return !this.isObstacle(x, y);
            }

            isWithinMapBounds(x, y) {
                return x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight;
            }

            isObstacle(x, y) {
                const currentMap = this.maps[this.currentMapId];
                const cell = currentMap.map[y][x];
                const obstacles = ['#', 'T', 'C', 'R', 'H', 'S', 'W'];
                return obstacles.includes(cell);
            }

            // ===== MAP TRANSITIONS =====
            checkMapTransition() {
                const currentMap = this.maps[this.currentMapId];
                if (!currentMap.exits) return;

                currentMap.exits.forEach(exit => {
                    if (this.isPlayerAtExit(exit)) {
                        this.transitionToMap(exit.targetMap, exit.targetX, exit.targetY);
                    }
                });
            }

            isPlayerAtExit(exit) {
                return this.playerX === exit.x && this.playerY === exit.y;
            }

            transitionToMap(mapId, x, y) {
                this.currentMapId = mapId;
                this.playerX = x;
                this.playerY = y;
                this.updateMessage(`Entered new area!`);
            }

            // ===== MAP MODE =====
            toggleMapMode() {
                this.isMapMode = !this.isMapMode;
                if (this.isMapMode) {
                    this.mapModeCurrentMap = this.currentMapId;
                    this.mapModeViewX = this.playerX - Math.floor(this.viewportWidth / 2);
                    this.mapModeViewY = this.playerY - Math.floor(this.viewportHeight / 2);
                    this.updateMessage("Map mode enabled. Use WASD to navigate, M to exit.");
                } else {
                    this.updateMessage("Map mode disabled.");
                }
                this.render();
            }

            handleMapModeInput(event) {
                const movement = this.getMovementFromKey(event.key);
                if (movement) {
                    this.moveMapModeCamera(movement.dx, movement.dy);
                    return;
                }

                // Switch between maps with number keys
                const mapKey = parseInt(event.key);
                if (!isNaN(mapKey) && mapKey >= 0 && mapKey < Object.keys(this.MAP_CONFIGS).length) {
                    this.mapModeCurrentMap = mapKey;
                    this.mapModeViewX = 0;
                    this.mapModeViewY = 0;
                    this.updateMessage(`Viewing Map ${mapKey}`);
                    this.render();
                }
            }

            moveMapModeCamera(dx, dy) {
                const newViewX = this.mapModeViewX + dx;
                const newViewY = this.mapModeViewY + dy;

                // Check if we need to transition to another map
                const transition = this.checkMapModeTransition(newViewX, newViewY);
                if (transition) {
                    this.mapModeCurrentMap = transition.targetMap;
                    this.mapModeViewX = transition.newViewX;
                    this.mapModeViewY = transition.newViewY;
                    this.updateMessage(`Moved to Map ${this.mapModeCurrentMap}`);
                } else {
                    // Normal camera movement within current map
                    this.mapModeViewX = Math.max(0, Math.min(newViewX, this.mapWidth - this.viewportWidth));
                    this.mapModeViewY = Math.max(0, Math.min(newViewY, this.mapHeight - this.viewportHeight));
                }
                this.render();
            }

            checkMapModeTransition(viewX, viewY) {
                const currentMapConfig = this.MAP_CONFIGS[this.mapModeCurrentMap];
                if (!currentMapConfig.exits) return null;

                // Check if camera is trying to go beyond map boundaries
                for (const exit of currentMapConfig.exits) {
                    // Check for transitions based on camera position and exit locations
                    if (this.isViewportAtExit(viewX, viewY, exit)) {
                        return {
                            targetMap: exit.targetMap,
                            newViewX: this.calculateTransitionViewX(exit),
                            newViewY: this.calculateTransitionViewY(exit)
                        };
                    }
                }
                return null;
            }

            isViewportAtExit(viewX, viewY, exit) {
                const viewportCenterX = viewX + Math.floor(this.viewportWidth / 2);
                const viewportCenterY = viewY + Math.floor(this.viewportHeight / 2);
                
                // Check if viewport center is near an exit
                const tolerance = 5;
                return Math.abs(viewportCenterX - exit.x) <= tolerance && 
                       Math.abs(viewportCenterY - exit.y) <= tolerance;
            }

            calculateTransitionViewX(exit) {
                // Position camera near the corresponding entrance in the target map
                return Math.max(0, Math.min(exit.targetX - Math.floor(this.viewportWidth / 2), 
                                           this.mapWidth - this.viewportWidth));
            }

            calculateTransitionViewY(exit) {
                return Math.max(0, Math.min(exit.targetY - Math.floor(this.viewportHeight / 2), 
                                           this.mapHeight - this.viewportHeight));
            }

            recordVisitedArea() {
                if (!this.visitedAreas[this.currentMapId]) {
                    this.visitedAreas[this.currentMapId] = new Set();
                }
                
                const viewport = this.calculateViewport();
                for (let y = viewport.viewY; y < viewport.viewY + this.viewportHeight; y++) {
                    for (let x = viewport.viewX; x < viewport.viewX + this.viewportWidth; x++) {
                        this.visitedAreas[this.currentMapId].add(`${x},${y}`);
                    }
                }
            }

            // ===== RENDERING =====
            render() {
                if (this.isMapMode) {
                    this.renderMapMode();
                } else {
                    this.renderGameMode();
                }
            }

            renderGameMode() {
                const currentMap = this.maps[this.currentMapId];
                const viewport = this.calculateViewport();
                const mapDisplay = this.generateMapDisplay(currentMap, viewport);

                document.getElementById('gameMap').textContent = mapDisplay;
                document.getElementById('playerPos').textContent = `${this.playerX},${this.playerY} (Map ${this.currentMapId})`;
            }

            renderMapMode() {
                const mapDisplay = this.generateMapModeDisplay();
                const connectionDiagram = this.generateConnectionDiagram();
                
                // Split display into map view (left) and connection diagram (right)
                const combinedDisplay = this.combineMapAndDiagram(mapDisplay, connectionDiagram);
                
                document.getElementById('gameMap').textContent = combinedDisplay;
                document.getElementById('playerPos').textContent = `Map Mode - Viewing Map ${this.mapModeCurrentMap} (${this.mapModeViewX},${this.mapModeViewY})`;
            }

            generateMapModeDisplay() {
                const currentMap = this.maps[this.mapModeCurrentMap];
                const visitedSet = this.visitedAreas[this.mapModeCurrentMap] || new Set();
                let mapDisplay = '';

                for (let y = this.mapModeViewY; y < this.mapModeViewY + this.viewportHeight; y++) {
                    for (let x = this.mapModeViewX; x < this.mapModeViewX + this.viewportWidth; x++) {
                        if (x < 0 || x >= this.mapWidth || y < 0 || y >= this.mapHeight) {
                            mapDisplay += ' ';
                        } else if (this.currentMapId === this.mapModeCurrentMap && x === this.playerX && y === this.playerY) {
                            mapDisplay += '@';
                        } else if (visitedSet.has(`${x},${y}`)) {
                            mapDisplay += currentMap.map[y][x];
                        } else {
                            mapDisplay += '?';
                        }
                    }
                    mapDisplay += '\n';
                }

                return mapDisplay.slice(0, -1); // Remove last newline
            }

            generateConnectionDiagram() {
                const mapNames = ['Forest', 'Plains', 'Desert', 'Mountains', 'Village', 'Cave', 'Lake'];
                let diagram = '';
                
                diagram += 'Map Connections:\n';
                diagram += '================\n';
                
                for (let mapId = 0; mapId < Object.keys(this.MAP_CONFIGS).length; mapId++) {
                    const isCurrentMap = mapId === this.mapModeCurrentMap;
                    const isPlayerMap = mapId === this.currentMapId;
                    const hasVisited = this.visitedAreas[mapId] && this.visitedAreas[mapId].size > 0;
                    
                    let prefix = '  ';
                    if (isCurrentMap) prefix = '> ';
                    else if (isPlayerMap) prefix = '@ ';
                    
                    diagram += `${prefix}${mapId}: ${mapNames[mapId]}`;
                    if (!hasVisited) diagram += ' (?)';
                    diagram += '\n';
                    
                    // Show connections
                    const config = this.MAP_CONFIGS[mapId];
                    if (config.exits) {
                        config.exits.forEach(exit => {
                            diagram += `    -> ${exit.targetMap}: ${mapNames[exit.targetMap]}\n`;
                        });
                    }
                    diagram += '\n';
                }
                
                return diagram;
            }

            combineMapAndDiagram(mapDisplay, diagram) {
                const mapLines = mapDisplay.split('\n');
                const diagramLines = diagram.split('\n');
                const maxLines = Math.max(mapLines.length, diagramLines.length);
                
                let combined = '';
                for (let i = 0; i < maxLines; i++) {
                    const mapLine = mapLines[i] || '';
                    const diagramLine = diagramLines[i] || '';
                    
                    // Pad map line to consistent width, add spacing, then diagram
                    const paddedMapLine = mapLine.padEnd(this.viewportWidth);
                    combined += paddedMapLine + '   ' + diagramLine + '\n';
                }
                
                return combined.slice(0, -1); // Remove last newline
            }

            calculateViewport() {
                let viewX = this.playerX - Math.floor(this.viewportWidth / 2);
                let viewY = this.playerY - Math.floor(this.viewportHeight / 2);

                viewX = Math.max(0, Math.min(viewX, this.mapWidth - this.viewportWidth));
                viewY = Math.max(0, Math.min(viewY, this.mapHeight - this.viewportHeight));

                return { viewX, viewY };
            }

            generateMapDisplay(currentMap, viewport) {
                let mapDisplay = '';

                for (let y = viewport.viewY; y < viewport.viewY + this.viewportHeight; y++) {
                    for (let x = viewport.viewX; x < viewport.viewX + this.viewportWidth; x++) {
                        if (x === this.playerX && y === this.playerY) {
                            mapDisplay += '@';
                        } else {
                            mapDisplay += currentMap.map[y][x];
                        }
                    }
                    mapDisplay += '\n';
                }

                return mapDisplay;
            }

            // ===== UI UPDATES =====
            updateMessage(message) {
                document.getElementById('messages').innerHTML = `<strong>Message:</strong> ${message}`;
            }

            // ===== WEBSOCKET CONNECTION =====
            connectWebSocket() {
                try {
                    this.websocket = new WebSocket(this.WS_URL);
                    
                    this.websocket.onopen = () => {
                        console.log('Connected to WebSocket');
                        this.isConnected = true;
                        this.updateMessage('Connected to server');
                        
                        // Join game with session ID
                        this.sendWebSocketMessage({
                            action: 'joinGame',
                            sessionId: this.sessionId,
                            data: {}
                        });
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('Failed to parse WebSocket message:', error);
                        }
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocket connection closed');
                        this.isConnected = false;
                        this.updateMessage('Disconnected from server');
                        
                        // Try to reconnect after 5 seconds
                        setTimeout(() => this.connectWebSocket(), 5000);
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateMessage('Connection error');
                    };
                } catch (error) {
                    console.error('Failed to connect WebSocket:', error);
                    this.updateMessage('Failed to connect to server');
                }
            }

            sendWebSocketMessage(message) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                } else {
                    console.warn('WebSocket not connected, message not sent:', message);
                }
            }

            handleWebSocketMessage(data) {
                console.log('Received WebSocket message:', data);
                
                switch (data.action) {
                    case 'joinGame':
                        if (data.type === 'success' && data.data.session) {
                            this.loadGameSession(data.data.session);
                        }
                        break;
                        
                    case 'generateMap':
                        if (data.type === 'success') {
                            this.handleGeneratedMap(data.data);
                        } else if (data.type === 'error') {
                            this.updateMessage(`Map generation failed: ${data.error}`);
                        } else if (data.type === 'update') {
                            this.updateMessage(data.data.message);
                        }
                        break;
                        
                    case 'move':
                        if (data.type === 'success') {
                            console.log('Move synchronized with server');
                        }
                        break;
                        
                    default:
                        console.log('Unknown WebSocket message action:', data.action);
                }
            }

            // ===== BACKEND INTEGRATION =====
            async generateMapWithAI(theme, description = '') {
                this.updateMessage('Requesting AI map generation...');
                
                if (this.isConnected) {
                    // Use WebSocket for real-time updates
                    this.sendWebSocketMessage({
                        action: 'generateMap',
                        sessionId: this.sessionId,
                        data: { theme, description }
                    });
                } else {
                    // Fallback to REST API
                    try {
                        const response = await fetch(`${this.API_BASE_URL}/maps/generate`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ theme, description })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            this.handleGeneratedMap(result);
                        } else {
                            this.updateMessage(`Map generation failed: ${result.error}`);
                        }
                    } catch (error) {
                        console.error('Failed to generate map:', error);
                        this.updateMessage('Failed to generate map');
                    }
                }
            }

            handleGeneratedMap(data) {
                const { mapId, mapData } = data;
                
                // Add new map to game
                const newMapIndex = Object.keys(this.MAP_CONFIGS).length;
                
                // Update configurations with generated data
                const themeKey = Object.keys(mapData.themeConfig)[0];
                const mapKey = Object.keys(mapData.mapConfig)[0];
                
                this.THEME_CONFIGS[themeKey] = mapData.themeConfig[themeKey];
                this.MAP_CONFIGS[newMapIndex] = {
                    theme: themeKey,
                    exits: mapData.mapConfig[mapKey].exits
                };
                
                // Create and store the map
                this.maps[newMapIndex] = {
                    map: mapData.mapArray,
                    theme: themeKey,
                    exits: mapData.mapConfig[mapKey].exits
                };
                
                this.updateMessage(`New ${themeKey} map generated! Use number ${newMapIndex} to visit.`);
                console.log('New map added:', { mapId, newMapIndex, theme: themeKey });
            }

            loadGameSession(session) {
                console.log('Loading game session:', session);
                
                // Update game state from server
                this.currentMapId = session.currentMap;
                this.playerX = session.playerX;
                this.playerY = session.playerY;
                
                // Load visited areas
                if (session.visitedAreas) {
                    this.visitedAreas = {};
                    session.visitedAreas.forEach(area => {
                        this.visitedAreas[area] = true;
                    });
                }
                
                this.updateMessage('Game session loaded from server');
                this.render();
            }

            saveGameState() {
                if (!this.isConnected) return;
                
                const gameState = {
                    currentMap: this.currentMapId,
                    playerX: this.playerX,
                    playerY: this.playerY,
                    visitedAreas: Object.keys(this.visitedAreas)
                };
                
                this.sendWebSocketMessage({
                    action: 'saveGameState',
                    sessionId: this.sessionId,
                    data: { sessionId: this.sessionId, gameState }
                });
            }

            // Override movement to sync with server
            movePlayer(dx, dy) {
                const newX = this.playerX + dx;
                const newY = this.playerY + dy;

                if (this.isValidMove(newX, newY)) {
                    this.playerX = newX;
                    this.playerY = newY;
                    this.recordVisitedArea();
                    
                    // Sync with server
                    if (this.isConnected) {
                        this.sendWebSocketMessage({
                            action: 'move',
                            sessionId: this.sessionId,
                            data: {
                                playerX: this.playerX,
                                playerY: this.playerY,
                                currentMap: this.currentMapId,
                                visitedAreas: Object.keys(this.visitedAreas)
                            }
                        });
                    }
                    
                    this.checkForMapTransition();
                    this.render();
                    
                    // Auto-save every few moves
                    if (Math.random() < 0.1) { // 10% chance
                        this.saveGameState();
                    }
                }
            }
        }

        // Start game
        const game = new SimpleRPG();
    </script>
</body>
</html>